#### Task and Thread key differencies:
1. **Threading Model**: Threads are managed by the operating system, while tasks are managed by the runtime environment.
2. **Resource Management**: Threads require explicit resource management, while tasks are managed by the runtime.
3. **Exception Handling**: Thread-based exceptions can be difficult to handle, while tasks provide a structured approach to exception handling.
#### Async and state machine(своїми словами)
https://www.youtube.com/watch?v=il9gl8MH17s&ab_channel=RawCoding
Асинхронне програмування реалізовано через state machine(машину станів). Це модель даних, яка зберігає дані про свій теперішній стейт. Наприклад, спрощено, при асинхронних функціях можна виділити стейт початковий, і очікування виконання функції. Коли виконується f програма, і зустрічається слово await, стейт машина змінює свій стейт на виконання і починає виконувати метод який викликається з await, поки він виконується, щоб не затримувати потік, виділяється новий потік(або не виділяється, це залежить від того, що викликається з await, це може бути просто I/O операція, яка не потребує потоку, а протсо передається системному планувальнику і очікує відповіді від нього), в якому код продовжує виконуватись окрім того методу який був викликаний через await, і стейт новоствореного потоку знову початковий(той новостворений потік виконує не той метод, в якому був викликаний перший await, а якийсь непов'язаний із ним метод в програмі, просто щоб не затримувати роботу). Коли метод викликаний await завершує своє виконання то стейт його потоку повертається у початковий і повертається до виконання зовнішнього методу.
#### Deadlock, resource races
**Deadlock** - випадок, коли два або більше потоків блокують один одного, чекаючи доступу до ресурсів, які вже заблоковані іншими потоками, в результаті чого програма зависає.
**Resource race (гонка за ресурси)** - випадок, коли результат програми залежить від порядку виконання потоків. Вона виникає, якщо кілька потоків одночасно звертаються до спільного ресурсу без належної синхронізації.
Подолати подібні проблеми допомагає семафор.
**Семафор** - це програмна конструкція, яка використовується для управління доступом до загальних ресурсів у багатопотоковому або багатозадачному середовищі. Загалом, він дозволяє обмежити кількість потоків, що працюють із певним ресурсом одночасно.
Основна ідея в тому, щоб перед запитом до певного ресурсу зменшувати кількість доступних потоків в семафорі, а після звільняти.
```
private static async Task CallGoogle()  
{  
    try  
    {  
        await _semaphore.WaitAsync();// асинхронне очікування, щоб не блокувати потік поки ресурс недоступний  
        var response = await _client.GetAsync("https://www.google.com/");  
        _semaphore.Release(); // звільнення семафора після завершення операції  
        Console.WriteLine(response.StatusCode);  
    }    
    catch (Exception ex)  
    {        
	    Console.WriteLine(ex.Message);  
	}
}
```
Таким чином, якщо інший потік захоче звернутись до цього ж методу, його запит відкладеться.
#### Parallelism and concurrency
**Concurrency** (конкурентність) — це здатність програми працювати з кількома завданнями одночасно. Завдання можуть, виконуватись послідовно, але з частим перемиканням (як у асинхронності).
**Parallelism** (паралелізм) — це здатність виконувати кілька завдань одночасно на різних фізичних ядрах процесора.

Паралелізм передбачає, що завдання розділені на незалежні частини, які можна виконувати одночасно. Це можливе завдяки апаратним ресурсам, наприклад багатоядерним процесорам. Реалізацією в .Net є бібліотеки паралельного програмування - це `Parallel.For`, `Task Parallel Library` (TPL) або `PLINQ`.

#### Про потоки 
Паралелізм реалізується багатопотоковістю, але не завжди потоки є дійсно паралельними у нашому .Net додатку. Дійсно паралельними є фізичні потоки процесора (зазвичай вони x2 від кількості ядер), а потоки які ми маємо в проектику .Net є псевдопаралельними. Кількість таких всевдопаралельних потоків видна в диспетчері задач у вкладці проца. 
Псевдопаралельні потоки емулюються розбиттям реального потоку на дуже дрібні проміжки часу роботи проца, які і виділяються на кожен віртуальний потік. 

## Багатопотоковість в коді

### Клас Thread
#### Методи
- Створення нового потоку: `Thread t = new Thread([any method]);`
- Штучна затримка потоку: `Thread.Sleep([time in milliseconds]);`
- Запуск потоку: `t.Start();`
- Небезпечний запуск (без перевірки, чи він не був уже запущений, права доступу, стану потоку): `t.UnsafeStart();`
- Приєднання потоку: `t.Join();` - зовнішній потік, в якому ми зараз викликаємо цей метод буде чекати, поки потік інстанса виконається і фактично "приєднається" до нашого потоку.
- Приєднання потоку з таймаутом: `t.Join(TimeSpan.FromSeconds(5));`

Важливо що thread має параметр Thread State, який визначає його теперішній стан

В Start також можна передавати параметри методу який виконується в потоці. Параметри в методі потрібно приймати як один об'єкт типу object і явно приводити до потрібного типу.
#### Параметри
1. ID: `t.ManagedThreadId`
2. Пріоритет: `t.Priority // Lowest/BelowNormal/Normal/AboveNormal/Highest`
3. Чи є фоновим: `t.IsBackground`
4. Назва: `t.Name`
5. Стан: `t.ThreadState // Unstarted/Running/WaitSleepJoin/Stopped ...`
6. Культура/UI Культура: `t.CurrentCulture; t.CurrentUICulture;` 

При роботі із Thread напряму, нам доводиться вручну хендлити стейти потоків, використовувати примітиви синхронізації і т. п., щоб це автоматизувати придумали клас ThreadPool.

### Клас ThreadPool
ThreadPool - це система управління потоками, яка дозволяє ефективно перевикористовувати потоки замість створення нових.

#### Методи
1. Додавання роботи в пул: `ThreadPool.QueueUserWorkItem(DoWork, dataToDoWork);`
		параметри: 
			- WaitCallback callBack(це делагат)
			- object? state (вхідні дані)
2. Отримання інформації про поточні налаштування пулу: 
	`ThreadPool.GetMaxThreads(out int workerThreads, out int completionPortThreads)`
3. Встановлення максимальної кількості потоків: `ThreadPool.SetMaxThreads(100,100);`
4. Отримання доступної кількості потоків: 
			`ThreadPool.GetAwailableThreads(out workerThreads, out completionPortThreads)`
5. Встановлення мінімальної кількості потоків: `ThreadPool.SetMinThreads(10, 10);`

## Примітиви синхронізації

Примітиви синхронізації - це така хуйня, яка має обмежити доступ до ресурсу між різними потоками, шоб не було помилок, бо до деяких ресурсів доступ повинен контролюватись.
Юзати їх може бути потрібно не тільки коли ти вручну хендлиш потоки через клас Thread. Навіть не обов'язково для цього явно працювати із потоками. Це може бути потрібно і при асинхронному програмуванні, і коли в тебе є якийсь бекграунд воркер, якийсь хостед сервіс який теоретично може звернутись до ресурсу доступ до якого треба буде обмежувати.
Деякі примітиви працюють на рівні CLR, а деякі через API Windows, через що вони обмежують доступ не тільки для потоків всередині нашої збірочки, а і для усіх процесів на сервері, шо доволі потужно і класно.

1. **Monitor (locker)** - блокує доступ до ресурсу усім іншим потокам. Можна юзати для захисту невеликої критичної секції коду в межах одного процесу.
Демонстрація:
```
var _locker = new object();  
  
ThreadPool.QueueUserWorkItem(_ =>  
{  
    Thread.Sleep(100);  
    lock (_locker)  
    {  
        Console.WriteLine("Locker is " + _locker);  
    }  
});  
  
lock (_locker)  
{  
    Thread.Sleep(1000);  
    Console.WriteLine("Press any key to exit...");  
}
```
2. Monitor (class) - дає трохи тонший контроль ніж lock. 
В Класі є можливість не тільки блокувати і вивільняти ресурс (Enter і Exit), а і сповіщати про очікування ресурсу (метод Wait блокує потік, поки ресурс не звільниться) і сповіщати очікуючі потоки про звільнення ресурсу (Pulse). Як я зроз це і так робиться в конструкції lock, просто в класі ти це робиш вручну, для душніл.
Демонстрація:
```
var _locker = new object();  
var isWaiting = false;// Флаг для перевірки, чи потік чекає на `Pulse`  
  
ThreadPool.QueueUserWorkItem(_ =>  
{  
    Monitor.Enter(_locker);  
    try  
    {  
        isWaiting = true;// Потік повідомляє, що чекає  
        Monitor.Pulse(_locker);// Сигналізуємо основному потоку, що можна викликати Pulse  
        Monitor.Wait(_locker);// Чекаємо сигналу  
        Console.WriteLine("Locker is " + _locker);  
    }  
    finally  
    {  
        Monitor.Exit(_locker);  
    }  
});  
  
Monitor.Enter(_locker);  
try  
{  
    while (!isWaiting)// Перевіряємо, чи потік у пулі готовий до очікування  
    {  
        Monitor.Wait(_locker);// Чекаємо, поки `isWaiting` стане true  
    }  
    Thread.Sleep(1000);  
    Console.WriteLine("Press any key to exit...");  
    Monitor.Pulse(_locker);// Сигналізуємо потоку в пулі  
}  
finally  
{  
    Monitor.Exit(_locker);  
}
```

3. Mutex - оцей уже працює на рівні ОС, але для того шоб він блокував ресурс між двома процесами, треба його однаково назвати в обох програмках. Наприклад, два окремих процеси можуть створити Mutex з однаковим іменем, і вони будуть розділяти доступ до ресурсу. Це особливість API Windows бо воно таку ж назву запиту в апі дає.
Демонстрація:
```
var myMutex = new Mutex(false, "MyMutex");  
  
for (var i = 0; i < 3; i++)  
{  
    Task.Run(() =>  
    {  
        Console.WriteLine($"Task {Task.CurrentId} waits");  
        if (myMutex.WaitOne())  
        {  
            try  
            {  
                Console.WriteLine($"Task {Task.CurrentId} runs");  
                Thread.Sleep(1000);  
            }  
            finally  
            {  
                Console.WriteLine($"Task {Task.CurrentId} releases mutex");  
                myMutex.ReleaseMutex();  
            }  
        }  
    });  
}  
Console.ReadLine();
```
4. Semaphore - теж працює на рівні ОС, і теж тільки якщо з однаковою назвою. Відрізняється від Мютекса тим, що може обмежувати кількість потоків, які працюють із ресурсом. Є ще SemaphoreSlim, це огризок, який працює тільки в межах CLR, але швидший і ще підтримує асинхронний WaitAsync.
Демонстрація:
```
var _semaphore = new Semaphore(5, 5);  
  
for (var i = 0; i < 10; i++)  
{  
    Task.Run(() =>  
    {  
        Console.WriteLine($"Task {Task.CurrentId} waits");  
        _semaphore.WaitOne();  
        Console.WriteLine($"Task {Task.CurrentId} enters the semaphore");  
        Thread.Sleep(1000);  
        Console.WriteLine($"Task {Task.CurrentId} releases the semaphore");  
        _semaphore.Release();  
    });  
  
}  
Console.ReadLine();
```