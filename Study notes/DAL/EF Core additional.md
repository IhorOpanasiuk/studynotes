## Ключі
З цікавого те, що немає необхідності прописувати в моделей явно foreign key колонки, якщо ми пишемо залежності через fluent API. А в конфігурації достатньо буде просто написати `builder.HasOne(x => x.Friend).WithMany()` і все.

## Міграції
Міграцію можна експортувати як sql-скрипт, для цього треба написати 
``` CLI
dotnet ef migrations script -o script.sql
```
Кожна міграція буде окремою транзакцією.
## Seed
Для заповнення бд даними в конфігурації треба написати `builder.HasData(Entity[])` і передати в метод масив екземплярів.

## Change Tracking

Зміни які ORM побачила але ще не зафіксувала в бд можна прочитати через 
`_dbContext.ChangeTracker.Entries();` який повертає масив об'єктів EntityEntry.

![[Pasted image 20241228013511.png]]
## Find and First difference
Різниця в тому, що якщо ми будемо більше 1-го разу шукати об'єкт через First, то будуть просто N запитів до бд, а якщо через Find, то запит буде 1. При пошуку через Find об'єкт зберігається у локальній пам'яті контексту даних EF, і наступні запити будуть шукати спочатку в цій локальній пам'яті.

Не обов'язково для кожної таблиці створювати DbSet. DbSet потрібен для можливості напряму звертатись до таблиці. Таблиця всеодно буде створена в бд якщо є ентіті зв'язана із сутністю із якої зробили DbSet.

## DbFirst context mapping
Щоб змапити контекст даних треба завантажити потрібні пакети EF Core, і пакет для взаємодії EF з вашою БД. У моєму це Npgsql. Запит на мапінг тоді буде такий:
```
dotnet ef dbcontext scaffold "Host=localhost;Port=5432;Database=vtc_shop;Username=postgres;Password=password" Npgsql.EntityFrameworkCore.PostgreSQL -o Models
```
після `dotnet ef dbcontext scaffold`  іде connectionString до БД, після чого ми даємо назву нашої бібліотеки для БД, після чого проперті -o із назвою папки в проекті, у уякій повинні бути розміщені файли із ентітісами.
## [[EF loading]]