**Патерн проектування** — це типовий спосіб вирішення певної проблеми, що часто зустрічається при проектуванні архітектури програм.

### Типи патернів
1. Породжувалльні - відповідають за зручне та безпечне створення нових об'єктів або навіть цілих сімейств об'єктів.
2. Структурні - відповідають за побудову зручних в підтримці ієрархій класів.
3. Поведінкові - вирішують завдання ефективної та безпечної взаємодії між об'єктами програми.
### Породжувальні
#### Фабричний метод *(Factory method)*
**Фабричний метод**  - патерн, який визначає загальний інтерфейс для створення об'єктів у суперкласі, дозволяючи підкласам змінювати тип створюваних об'єктів.
![[Pasted image 20241211213216.png]]
Суть його в тому, щоб зробити абстрактний клас "створювач" і інтерфейс "продукту", після чого створювати похідні від них реалізації створювачів і продуктів як відповідно будуть створювати відповідні продукти. 
В основному цей патерн використовується щоб запобігти використанню багатьох операторів умови де ми перебираємо вхідні якісь умови і на основі них створюємо об'єкт. Це дозволяє дотриматись Open-closed принципу.
#### Абстрактна фабрика *(Abstract factory)*
**Абстрактна фабрика**  - це патерн, що дає змогу створювати сімейства пов'язаних об'єктів, не прив'язуючись до конкретних класів створюваних об'єктів.
![[Pasted image 20241211214155.png]]
Приклад: якщо уявити, що якась програмка є кросплатформеною, і вона просто визначає, що в ній десь використовується якась кнопка. Кнопка надається передвизначеною UI операційної системи. Button є інтерфейсом продукта, а MacFactory є реалізацією фабрики
![[Pasted image 20241211214425.png]]
#### Будівельник *(Builder)*
**Будівельник**  - це патерн, що дає змогу створювати складні об'єкти крок за кроком. Будівельник дає можливість використовувати один і той самий код будівництва для отримання різних відображень об'єктів.
Суть у тому, щоб створити клас, який може робити маніпуляції над об'єктом, доповнюючи його, додаючи умовно нові модулі до його функціональностей. Як, наприклад, умовний продюсер автомобілів будує каркас автомобіля, потім вставляє двері, сидіння і тп. Таким чином використовуючи не купу перевантажених конструкторів для об'єкта, а замінюючи це поетапним процесом маніпуляцій з боку білдера.
![[Pasted image 20241211214920.png]]
#### Прототип *(Prototype)*
**Прототип** - це патерн, що дає змогу копіювати об'єкти, не вдаючись до їхньої реалізації.
Суть в тому, щоб придумати інтерфейс (в .Net це ICloneable), який вказує на те, що  об'єкт, який його реалізує, може клонувати свою реалізацію. І таким чином за потреби просити самого об'єкта склонувати себе щоб отримати на зовні реалізацію в новому об'єкту, яку ззовні неможливо клонувати через їх приватність.
![[Pasted image 20241211220755.png]]
#### Одинак (*Singleton*)
**Одинак** - це патерн, який гарантує, що клас має лише оддин екземпляр, та надає глобальну точку доступу до нього.
В основному використовується якщо треба гарантувати одну точку входу для доступу до конкретного ресурсу, наприклад, якийсь клас взаємодії із файлами, чи ще чимось, із чим неможливо працювати з кількох сервісів одночасно. Іще приклади: логування, підключення до БД.

### Структурні
#### Адаптер (*Adapter*)
**Адаптер** - це патерн, який дає змогу об'єкткам із несумісними інтерфейсами працювати разом.
Суть в тому, щоб надати можливість взаємодії двох умовний лібок, які потребують обміну даними, але одна із них, наприклад, підтримує тільки XML формат передачі даних, а інша JSON, якщо зробити парсер XML в JSON у правильному вигляді, зрозумілому для іншої лібки, то можна буде налаштувати їхню взаємодію, це і є патерн адаптер.
![[Pasted image 20241212103920.png]]
#### Міст (*Bridge*)
**Міст** - це патерн, який розділяє один або кілька класів на абстракцію та реалізацію, дозволяючи змінювати код в одній гілці класів, незалежно від іншої.
По суті, це той самий патерн який релізує гнучку архітектуру, в якій наші сервіси бізнес-логіки не залежать напряму від конкретних репозитріїв бд, усі залежності повинні бути побудовані на абстракціях, ми кожному сервісу і репозиторію (і не тільки) робим свій інтерфейс, і інджектимо в інших сервісах теж інтерфейси.

#### Компонувальник (*Composite*)
**Компонувальник** — це патерн, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.
Суть у тому, що він дозволяє структуризувати набір елементів, що вкладені один в одного. Наприклад, в нас є клас коробка і клас річ. Коробка може містити речі або інші коробки, таким чином утворюється ніби дерево елементів, що і є реалізацією патерна компонувальник.
![[Pasted image 20241212135103.png]]
#### Декоратор (*Decorator*)
**Декоратор** — це патерн, що дає змогу динамічно додавати об’єктам нову функціональність, загортаючи їх у корисні «обгортки».
Зазвичай його пояснюють на прикладі нотифікаторів, коли для різних клієнтів потрібно нагадувати про якісь події різними комбінаціями нотифікаторів, і щоб не створювати для кожної такої комбінації свою логіку, використовується патерн декоратор. Суть у тому, щоб створити інтерфейс такого нотифікатора, і його базовий клас, від якого успадковувати вже реалізації, і у кожній реалізації при перевизначенні метода також викликати базову реалізацію, такм чином, маожна буде додавати функціонал до кожного такого класу, створюючи із екземпляра, екземпляр іншого класу, додаючи до нього додатковий функціонал.
![[Pasted image 20241212135513.png]]
#### Фасад (*Facade*)
Фасад - це патерн, який надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.
Суть банально в тому, щоб із своєї бібліотеки, окрім основного інтерфейсу взаємодії, давати інтерфейс для взаємодії настільки простим, наскільки це можливо, приховуючи деталі реалізації, навіть якщо при цьому не буде використовуватись увесь її функціонал.
![[Pasted image 20241212140310.png]]
#### Легковаговик (*Flyweight*)
**Легковаговик** — це патерн, що дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Легковаговик заощаджує пам’ять, розподіляючи спільний стан об’єктів між собою, замість зберігання однакових даних у кожному об’єкті.
Суть у тому, щоб не зберігати в класах ті поля, які є спільними для багатьох подібних класів. Як приклад наводиться відеогра-шутер, де можна зберігати спрайт кулі в об'єкті кулі, тоді якщо вистрелити дуже багато куль, то буде в пам'ять разом з ними завантажено таку ж кількість однакових спрайтів. За патерном легковаговик, варто цей спрайт зберігати окремо від самих об'єктів, а в об'єктах зберігати тільки лінку на них, таким чином сильно заощаджуючи пам'ять.
Пропонується зберігати сам спрайт в окремому класі-контексті.
![[Pasted image 20241212141029.png]]
#### Замісник (*Proxy*)
**Замісник** — це патерн, що дає змогу підставляти замість реальних об’єктів спеціальні об’єкти-замінники. Ці об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось _до_ чи _після_ передачі виклику оригіналові.
Суть в тому, щоб створити об'єкт, який буде перехоплювати запити до якогось ресурсу, і виконувати певні дії до, або після цього запиту. Реалізацією такого патерна в Asp.Net є Middlewares і Fitlers.

### Поведінкові
#### Ланцюжок обов'язків (*Chain of Responsibility*)
**Ланцюжок обов’язків** — це патерн, що дає змогу передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам і чи варто передавати запит далі ланцюжком.
Пояснюється на зрозумілому прикладі мідлвеєрів в asp.net. Кожен мідлвеєр отримує доступ до запиту відповідно до послідовності в черзі, в якій він підключений в файлі Program.cs, також кожен мідлвеєр має ссилку на наступний мідлвеєр для передачі даних йому.
![[Pasted image 20241212174318.png]]
#### Команда (*Action/Command*)
**Команда** — це патерн, який перетворює запити на об’єкти, дозволяючи передавати їх як аргументи під час виклику методів, ставити запити в чергу, логувати їх, а також підтримувати скасування операцій.
Суть в тому, що відповідно до цього патерна, не потрібно створювати, умовно, об'єкти кнопок для виконання кожної задачі програми, такм чином роблячи взаємозалежним дизайн кнопки від конкретної команди. Дещо складно зрозуміти даний патерн, бо він по факту завжди вже реалізований і застосовується, і скалдно уявити як можна без нього, тому мені складно його пояснити своїми словами.
![[Pasted image 20241212174703.png]]
![[Pasted image 20241212174713.png]]
#### Ітератор (*Iterator*)
**Ітератор** — це патерн, що дає змогу послідовно обходити елементи складових об’єктів, не розкриваючи їхньої внутрішньої організації.
Ну по суті це банальний цикл foreach і інтерфейс IEnumerable.

#### Посередник (*Mediator*)
**Посередник** — це патерн, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.
Приклад: мається якась форма/діалог із купою різних об'єктів на них, команди викликаються одні між іншим і таким чином побудована взаємодія, але ми можемо створити клас "діалог" із яким взаємодіять усі інші об'єкти, які є в діалозі, а вже всередині цього класу побудована взаємодія із зовнішніми для нього компонентами.
![[Pasted image 20241213132508.png]]![[Pasted image 20241213132518.png]]
![[Pasted image 20241213132632.png]]
Стурктура абстрактна:
![[Pasted image 20241212180657.png]]
#### Знімок (Memento)
**Знімок** — це патерн, що дає змогу зберігати та відновлювати минулий стан об’єктів, не розкриваючи подробиць їхньої реалізації.
Це якийсь прототип на максималках, просто суть в тому що знімок передбачає створення не самих копій об'єктів, а знімків тільки їх даних, які можна потім завантажити щоб відновити попередній стан одного й того ж об'єкта. Також особливістю є те, що самі знімки незмінні, правильно було б робити його поля readonly, таким чином захищаючи дані в них, а сама структура в основному складається із Originator - безпосередньо класу який має робити свої фрейми, Snapshot(Memento) - безпосередньо той фрейм/знімок, і Caretaker - це зовнішній клас який і може попросити originator щоб він зробив снепшот чи його завантажив
Структура:
![[Pasted image 20241213134159.png]]
#### Спостерігач (Observer)
**Спостерігач** — це патерн, який створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах.
Основна реалізація полягає в тому, щоб банально в класі, де мають відбутись події, на які ми хочем підписати інші об'єкти, тобто їх методи якісь, оголосити event, і викликати цей event при відповідних подіях в даному класі. Наприклад, в WPF є інтерфейс INotifyPropertyChanged, який в основному використовується для, відповідно, сповіщення про зміну якогось параметру, зазвичай це якась ViewModel, сповіщати про оновлення проперті потрібно щоб в реальному часі змінювати відображене значення на основі поля моделі, саме так це працює в WPF(там немає useState як в React). 
Отже створюється івент, описується для нього делегат, і також в класі описують методи для підписки на цей івент, щоб це було можливо зробити ззовні, і таким чином відбувається взаємодія.
В структурі показано трохи складніше, бо самі івенти як функціонал наявні не у всіх мовах програмування, і треба показати цей механізм на простіших командах:
![[Pasted image 20241213135645.png]]

#### Стан (State)
**Стан** - це патерн, що дає змогу об’єктам змінювати поведінку в залежності від їхнього стану. Ззовні створюється враження, ніби змінився клас об’єкта.
Суть у тому, щоб дотриматись принципу open-closed при роботі із станами, реалізувати машину станів, шляхом створення інтерфейсу стану, класів-реалізацій станів до об'єкта-контексту, який ці стани і зберігає, замість використання величезних умовних операторів.
Контекст передає класу стейт себе, а клас стейт містить безпосередньо маніпуляції, які потрібно виконати до класу контексту залежно від його теперішнього стейту. Таким чином будується ланцюжок маніпуляцій із контекстом, який не потребує вручну описувати умовний оператор для кожного стейта.
Структура:
![[Pasted image 20241213140428.png]]
#### Стратегія (Strategy)
**Стратегія** — це патерн, який визначає сімейство схожих алгоритмів і розміщує кожен з них у власному класі. Після цього алгоритми можна заміняти один на інший прямо під час виконання програми.
Суть в тому, щоб розділити логіку якогось великого класу, якщо є методи, які є взаємозамінними, просто потрібні в різних випадках, (тобто виконуються якусь одну задачу, але різними способами, а способи можуть бути потрібні різні) то є сенс усі ці методи винести в окремі класи(стратегії), яким надати спільний інтерфейс, таким чином в зовнішньому класі, де він юзається, підставляти в поле відповідного інтерфейсу стратегії екземпляр потрібний в даний момент часу.
![[Pasted image 20241213141730.png]]
#### Шаблонний метод (Template method)
**Шаблонний метод** — це патерн, який визначає кістяк алгоритму, перекладаючи відповідальність за деякі його кроки на підкласи. Патерн дозволяє підкласам перевизначати кроки алгоритму, не змінюючи його загальної структури.
Суть в тому, що цей патерн дозволяє певний алгоритм модифіковувати. Для цього алгоритм описують у методі певного абстрактного класу, алгоритм складається з інших методів, які можуть бути як абстрактні, так і віртуальні, залежно від того, чи точно потрібно перевизначати їх у дочірніх класах, чи можна в деяких залишити базову реалізацію.
Таким чином, можна створювати нові класи алгоритмів, які успадковуємо від базового і змінювати йому певні кроки. 
Окрім самих кроків, часто можна описувати і хуки - це дії, які виконуються між кроками, і по дефолту в оригінальному абстрактному класі нічого не виконують. Вони існують для того, щоб в дочірніх класах можна було вклинити певні дії між іншими кроками, не змінюючи самі кроки для цього.
![[Pasted image 20241213142733.png]]

#### Відвідувач (Visitor)
**Відвідувач** — це патерн, що дає змогу додавати до програми нові операції, не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.
Тут суть в тому, що можуть бути випадки, коли поліморфізм і опис певних методів всередині класу не хочеться використовувати з огляду на сильний розрив у тематиці методів взаємодії із класом. Коли в нас є якийсь клас що робить певні обчислення пов'язані із, наприклад, літаковою промисловістю, і нам потрібно додати його XML-серіалізацію, ми не хочемо поміщати цю логіку всередину даного класу і описувати до нього інтерфейс. Для цього створюється клас Visitor, який має певну функціональність (в нашому випадку XML-серіалізацію) одразу до всіх класів, до яких вона в нас може бути застосована. Таким чином у відвідувачі банально описана велика кількість або перевантажених методів, або просто методів з різними сигнатурами для роботи із різними класами і виконання над ними подібних маніпуляцій. 
Зрозуміліше показано на схемі:
![[Pasted image 20241213152740.png]]![[Pasted image 20241213152830.png]]
