
![[Excalidraw/DRAW_task-thread diagram.excalidraw]] 

# Parallelism and concurrency theory
**Concurrency** (конкурентність) — це здатність програми працювати з кількома завданнями одночасно. Завдання можуть, виконуватись послідовно, але з частим перемиканням (як у асинхронності).
**Parallelism** (паралелізм) — це здатність виконувати кілька завдань одночасно на різних фізичних ядрах процесора.

Паралелізм передбачає, що завдання розділені на незалежні частини, які можна виконувати одночасно. Це можливе завдяки апаратним ресурсам, наприклад багатоядерним процесорам. Реалізацією в .Net є бібліотеки паралельного програмування - це `Parallel.For`, `Task Parallel Library` (TPL) або `PLINQ`.
## Deadlock, resource races
**Deadlock** - випадок, коли два або більше потоків блокують один одного, чекаючи доступу до ресурсів, які вже заблоковані іншими потоками, в результаті чого програма зависає.
**Resource race (гонка за ресурси)** - випадок, коли результат програми залежить від порядку виконання потоків. Вона виникає, якщо кілька потоків одночасно звертаються до спільного ресурсу без належної синхронізації.
Подолати подібні проблеми допомагає семафор.
**Семафор** - це програмна конструкція, яка використовується для управління доступом до загальних ресурсів у багатопотоковому або багатозадачному середовищі. Загалом, він дозволяє обмежити кількість потоків, що працюють із певним ресурсом одночасно.
Основна ідея в тому, щоб перед запитом до певного ресурсу зменшувати кількість доступних потоків в семафорі, а після звільняти.
```
private static async Task CallGoogle()  
{  
    try  
    {  
        await _semaphore.WaitAsync();// асинхронне очікування, щоб не блокувати потік поки ресурс недоступний  
        var response = await _client.GetAsync("https://www.google.com/");  
        _semaphore.Release(); // звільнення семафора після завершення операції  
        Console.WriteLine(response.StatusCode);  
    }    
    catch (Exception ex)  
    {        
	    Console.WriteLine(ex.Message);  
	}
}
```
Таким чином, якщо інший потік захоче звернутись до цього ж методу, його запит відкладеться.

# Асинхронність в коді
## Async and state machine(своїми словами)
https://www.youtube.com/watch?v=il9gl8MH17s&ab_channel=RawCoding
Асинхронне програмування реалізовано через state machine(машину станів). Це модель даних, яка зберігає дані про свій теперішній стейт. Наприклад, спрощено, при асинхронних функціях можна виділити стейт початковий, і очікування виконання функції. Коли виконується програма, і зустрічається слово await, стейт машина змінює свій стейт на виконання і починає виконувати метод який викликається з await, поки він виконується, щоб не затримувати потік, виділяється новий потік(або не виділяється, це залежить від того, що викликається з await, це може бути просто I/O операція, яка не потребує потоку, а протсо передається системному планувальнику і очікує відповіді від нього), в якому код продовжує виконуватись окрім того методу який був викликаний через await, і стейт новоствореного потоку знову початковий(той новостворений потік виконує не той метод, в якому був викликаний перший await, а якийсь непов'язаний із ним метод в програмі, просто щоб не затримувати роботу). Коли метод викликаний await завершує своє виконання то стейт його потоку повертається у початковий і повертається до виконання зовнішнього методу.
## Task and Thread key differencies:
1. The Thread class is used for creating and manipulating a thread in Windows. A Task represents some asynchronous operation. 
2. The task can return a result. There is no direct mechanism to return the result from a thread. 
3. Task supports cancellation through the use of cancellation tokens. But Thread doesn't. 
4. A task can have multiple processes happening at the same time. Threads can only have one task running at a time. 
5. A new Thread() is not dealing with Thread pool thread, whereas Task do use thread pool thread. 
6. A Task is a higher level concept than Thread.
## ValueTask
Асинхронний метод може повертати деяке значення. Тоді значення, що повертається
значення обертається в об'єкт Task, а типом, що повертається, є Task. Використання типу ValueTask багато в чому аналогічне застосуванню Task за винятком деяких відмінностей у роботі з пам'яттю, оскільки ValueTask - структура структура, а Task - клас. За замовчуванням тип ValueTask недоступний, і щоб використовувати його, спочатку треба встановити через NuGet пакет System.Threading.Tasks.Extensions.

### Configure Await
ConfigureAwait - це екстеншн до виклику будь-якого асинхронного виклику: 
``` C#
await Task.Delay(10).ConfigureAwait(false);
```
Він визначає те, чи обов'язково після виконання даного асинхронного методу, повертатись до виконання саме тим потоком, який його викликав. Насправді, це важливо в програмах де є UI, по типу WPF, щоб не зависав сам UI, і тому там по дефолту встановлено `ConfigureAwait(true)` для асинхронних операцій. 
**Але у бекенді (ASP.NET Core) `SynchronizationContext` немає(немає єдиного основного потоку)!**  Тому `ConfigureAwait(false)` **майже не впливає** на продуктивність в ASP.NET Core.
## SynchronizationContext
SynchronizationContext — це механізм, який **визначає, в якому потоці виконуватиметься подальший код після `await`**. У 99.9% випадків SynchronizationContext використовується просто як тип з віртуальним методом Post, який приймає делегат на асинхронне виконання.
Він зберігає **контекст виконання**, тобто інформацію про **поточний потік або середовище**, у якому має продовжуватися робота після завершення асинхронної операції.
#### Як це працює у різних середовищах?
1. **WPF / WinForms** 
    - `SynchronizationContext` прив'язаний до **головного UI-потоку**.
    - Після `await` код **завжди повертається у UI-потік**, щоб можна було оновлювати інтерфейс.
2. **ASP.NET (старий .NET Framework)**
    - `SynchronizationContext` прив'язаний до **потоку обробки HTTP-запиту**.
    - Після `await` код повертається **в той самий потік обробки запиту**.
3. **ASP.NET Core**
    - **Немає `SynchronizationContext`!**
    - Після `await` код може продовжити виконуватись **у будь-якому потоці**.
    - Це дає **вищу продуктивність** і **менше блокувань**.
4. **Консольні застосунки**
    - `SynchronizationContext` зазвичай **відсутній** (тобто `null`).
    - `await` після виконання операції **продовжує роботу у випадковому потоці з `ThreadPool`**.
### Планувальник задач
SynchronizationContext це загальна абстракція для «планувальника». Делегати в Task,
які можуть бути поставлені в чергу і виконані, пов'язані з TaskScheduler. Планувальник за замовчуванням, який повертає TaskScheduler.Default, являє собою пул потоків. Також бібліотеки включають тип ConcurrentExclusiveSchedulerPair. Екземпляр цього класу надає дві властивості TaskScheduler: ExclusiveScheduler і ConcurrentScheduler.
Припустімо, натискання кнопки ініціює скачування тексту і встановлює його в Content кнопки. Кнопка має бути доступною тільки з UI потоку, в якому вона і знаходиться, тому, коли ми успішно завантажуємо дату і час і хочемо розмістити їх у Content кнопки, нам потрібно це зробити з потоку, який має над нею контроль.
Ми можемо вручну використовувати SynchronizationContext, щоб встановити Content у вихідному контексті, наприклад через TaskScheduler. А можемо використовувати SynchronizationContext безпосередньо.
За замовчуванням очікування завдання звертається до SynchronizationContext.Current і
TaskScheduler.Current. Коли ви «очікуєте» що-небудь у C#, компілятор перетворює код для опитування (викликом методу GetAwaiter) «очікуваного» (у цьому випадку Task) для «того, хто очікує» (TaskAwaiter). «Очікувач» відповідає за приєднання коллбека (часто званого «продовженням»), який здійснює зворотний виклик у кінцевий автомат після завершення очікування. Він реалізує це, використовуючи той контекст/планувальник, який захопив під час реєстрації колбека. 
А ConfigureAwait(continueOnCapturedContext: false) використовується для запобігання примусового виклику колбека у вихідному контексті або планувальнику. Іншими словами, вказуючи false, навіть за наявності поточного контексту або планувальника для зворотного виклику, мається на увазі, що він відсутній.
Це дає нам кілька переваг: Поліпшення продуктивності, Запобігання дедлокам.
# Багатопотоковість в коді
## Про потоки 
Паралелізм реалізується багатопотоковістю, але не завжди потоки є дійсно паралельними у нашому .Net додатку. Дійсно паралельними є фізичні потоки процесора (зазвичай вони x2 від кількості ядер), а потоки які ми маємо в проектику .Net є псевдопаралельними. Кількість таких всевдопаралельних потоків видна в диспетчері задач у вкладці проца. 
Псевдопаралельні потоки емулюються розбиттям реального потоку на дуже дрібні проміжки часу роботи проца, які і виділяються на кожен віртуальний потік. 
## Клас Thread
### Методи
- Створення нового потоку: `Thread t = new Thread([any method]);`
- Штучна затримка потоку: `Thread.Sleep([time in milliseconds]);`
- Запуск потоку: `t.Start();`
- Небезпечний запуск (без перевірки, чи він не був уже запущений, права доступу, стану потоку): `t.UnsafeStart();`
- Приєднання потоку: `t.Join();` - зовнішній потік, в якому ми зараз викликаємо цей метод буде чекати, поки потік інстанса виконається і фактично "приєднається" до нашого потоку.
- Приєднання потоку з таймаутом: `t.Join(TimeSpan.FromSeconds(5));`

Важливо що thread має параметр Thread State, який визначає його теперішній стан
В Start також можна передавати параметри методу який виконується в потоці. Параметри в методі потрібно приймати як один об'єкт типу object і явно приводити до потрібного типу.
### Параметри
1. ID: `t.ManagedThreadId`
2. Пріоритет: `t.Priority // Lowest/BelowNormal/Normal/AboveNormal/Highest`
3. Чи є фоновим: `t.IsBackground`
4. Назва: `t.Name`
5. Стан: `t.ThreadState // Unstarted/Running/WaitSleepJoin/Stopped ...`
6. Культура/UI Культура: `t.CurrentCulture; t.CurrentUICulture;` 

При роботі із Thread напряму, нам доводиться вручну хендлити стейти потоків, використовувати примітиви синхронізації і т. п., щоб це автоматизувати придумали клас ThreadPool.
## Клас ThreadPool
ThreadPool - це система управління потоками, яка дозволяє ефективно перевикористовувати потоки замість створення нових.
### Методи
1. Додавання роботи в пул: `ThreadPool.QueueUserWorkItem(DoWork, dataToDoWork);`
		параметри: 
			- WaitCallback callBack(це делагат)
			- object? state (вхідні дані)
2. Отримання інформації про поточні налаштування пулу: 
	`ThreadPool.GetMaxThreads(out int workerThreads, out int completionPortThreads)`
3. Встановлення максимальної кількості потоків: `ThreadPool.SetMaxThreads(100,100);`
4. Отримання доступної кількості потоків: 
			`ThreadPool.GetAwailableThreads(out workerThreads, out completionPortThreads)`
5. Встановлення мінімальної кількості потоків: `ThreadPool.SetMinThreads(10, 10);`

## Примітиви синхронізації

Примітиви синхронізації - це така хуйня, яка має обмежити доступ до ресурсу між різними потоками, шоб не було помилок, бо до деяких ресурсів доступ повинен контролюватись.
Юзати їх може бути потрібно не тільки коли ти вручну хендлиш потоки через клас Thread. Навіть не обов'язково для цього явно працювати із потоками. Це може бути потрібно і при асинхронному програмуванні, і коли в тебе є якийсь бекграунд воркер, якийсь хостед сервіс який теоретично може звернутись до ресурсу доступ до якого треба буде обмежувати.
Деякі примітиви працюють на рівні CLR, а деякі через API Windows, через що вони обмежують доступ не тільки для потоків всередині нашої збірочки, а і для усіх процесів на сервері, шо доволі потужно і класно.

1. **Monitor (locker)** - блокує доступ до ресурсу усім іншим потокам. Можна юзати для захисту невеликої критичної секції коду в межах одного процесу.
Демонстрація:
``` C#
var _locker = new object();  
  
ThreadPool.QueueUserWorkItem(_ =>  
{  
    Thread.Sleep(100);  
    lock (_locker)  
    {  
        Console.WriteLine("Locker is " + _locker);  
    }  
});  
  
lock (_locker)  
{  
    Thread.Sleep(1000);  
    Console.WriteLine("Press any key to exit...");  
}
```
2. Monitor (class) - дає трохи тонший контроль ніж lock. 
В Класі є можливість не тільки блокувати і вивільняти ресурс (Enter і Exit), а і сповіщати про очікування ресурсу (метод Wait блокує потік, поки ресурс не звільниться) і сповіщати очікуючі потоки про звільнення ресурсу (Pulse). Як я зроз це і так робиться в конструкції lock, просто в класі ти це робиш вручну, для душніл.
Демонстрація:
``` C#
var _locker = new object();  
var isWaiting = false;// Флаг для перевірки, чи потік чекає на `Pulse`  
  
ThreadPool.QueueUserWorkItem(_ =>  
{  
    Monitor.Enter(_locker);  
    try  
    {  
        isWaiting = true;// Потік повідомляє, що чекає  
        Monitor.Pulse(_locker);// Сигналізуємо основному потоку, що можна викликати Pulse  
        Monitor.Wait(_locker);// Чекаємо сигналу  
        Console.WriteLine("Locker is " + _locker);  
    }  
    finally  
    {  
        Monitor.Exit(_locker);  
    }  
});  
  
Monitor.Enter(_locker);  
try  
{  
    while (!isWaiting)// Перевіряємо, чи потік у пулі готовий до очікування  
    {  
        Monitor.Wait(_locker);// Чекаємо, поки `isWaiting` стане true  
    }  
    Thread.Sleep(1000);  
    Console.WriteLine("Press any key to exit...");  
    Monitor.Pulse(_locker);// Сигналізуємо потоку в пулі  
}  
finally  
{  
    Monitor.Exit(_locker);  
}
```

3. Mutex - оцей уже працює на рівні ОС, але для того шоб він блокував ресурс між двома процесами, треба його однаково назвати в обох програмках. Наприклад, два окремих процеси можуть створити Mutex з однаковим іменем, і вони будуть розділяти доступ до ресурсу. Це особливість API Windows бо воно таку ж назву запиту в апі дає.
Демонстрація:
``` C#
var myMutex = new Mutex(false, "MyMutex");  
  
for (var i = 0; i < 3; i++)  
{  
    Task.Run(() =>  
    {  
        Console.WriteLine($"Task {Task.CurrentId} waits");  
        if (myMutex.WaitOne())  
        {  
            try  
            {  
                Console.WriteLine($"Task {Task.CurrentId} runs");  
                Thread.Sleep(1000);  
            }  
            finally  
            {  
                Console.WriteLine($"Task {Task.CurrentId} releases mutex");  
                myMutex.ReleaseMutex();  
            }  
        }  
    });  
}  
Console.ReadLine();
```
4. Semaphore - теж працює на рівні ОС, і теж тільки якщо з однаковою назвою. Відрізняється від Мютекса тим, що може обмежувати кількість потоків, які працюють із ресурсом. Є ще SemaphoreSlim, це огризок, який працює тільки в межах CLR, але швидший і ще підтримує асинхронний WaitAsync.
Демонстрація:
``` C#
var _semaphore = new Semaphore(5, 5);  
  
for (var i = 0; i < 10; i++)  
{  
    Task.Run(() =>  
    {  
        Console.WriteLine($"Task {Task.CurrentId} waits");  
        _semaphore.WaitOne();  
        Console.WriteLine($"Task {Task.CurrentId} enters the semaphore");  
        Thread.Sleep(1000);  
        Console.WriteLine($"Task {Task.CurrentId} releases the semaphore");  
        _semaphore.Release();  
    });  
  
}  
Console.ReadLine();
```

## Interlocked
Клас Interlocked дає змогу створювати прості оператори для атомарних операцій з
змінними.
Наприклад, операція i++ не є безпечною щодо потоків. Вона передбачає вилучення значення з пам'яті, збільшення цього значення на 1 і його зворотне збереження в пам'яті. Такі операції можуть перериватися планувальником потоків.
Клас Interlocked надає методи, що дають змогу виконувати інкремент, декремент, обмін і зчитування значень у безпечній до потоків манері.
Застосування класу Interlocked є набагато швидшим підходом у порівнянні з іншими прийомами щодо забезпечення синхронізації. Однак користуватися ним можна для усунення тільки простих наслідків синхронізації.
Нижче наведено основні члени цього класу:

| Член              | Призначення                                                                                         |
| ----------------- | --------------------------------------------------------------------------------------------------- |
| CompareExchange() | Безпечно перевіряє 2 значення на еквівалентність. Якщо вони рівнв, змінює одне із значень не третє. |
| Decrement()       | Безпечно зменшує значення на 1                                                                      |
| Exchange()        | Безпечно змінює 2 значення місцями                                                                  |
| Increment()       | Безпечно збільшує значення на 1                                                                     |
## Volatile
Ключове слово `volatile` означає, що поле може змінити кілька потоків, які виконуються одночасно. Додавання модифікатора `volatile` гарантує, що всі потоки будуть бачити тимчасові записи, що виконуються іншим потоком, у порядку їхнього виконання. Немає жодної гарантії єдиного загального порядку тимчасових записів у всіх потоках виконання.
Ключове слово `volatile` може застосовуватися до полів таких типів:
- Посилальні типи.
- Типи покажчиків (у небезпечному контексті).
- Прості типи, наприклад sbyte, byte, short, ushort, int, uint, char, float і bool.
- Тип enum з одним із таких базових типів: byte, sbyte, short, ushort, int
або uint.
- IntPtr і UIntPtr.
Інші типи, включно з double і long, не можна забезпечити модифікатором volatile, тому що
що для них не гарантується атомарність операцій читання і запису.
Ключове слово
volatile можна застосовувати тільки до полів class або struct. Локальні змінні не можуть оголошуватися як volatile.
Приклад:
``` C#
using System;
using System.Threading;

class Program
{
    private static volatile bool isRunning = true; // Гарантує, що зміни бачать всі потоки

    static void Main()
    {
        Thread worker = new Thread(Work);
        worker.Start();

        Console.WriteLine("Натисніть будь-яку клавішу, щоб зупинити потік...");
        Console.ReadKey();
        isRunning = false; // Змінюємо значення, яке бачать всі потоки

        worker.Join(); // Чекаємо завершення потоку
        Console.WriteLine("Потік завершено.");
    }

    static void Work()
    {
        while (isRunning)
        {
            Console.WriteLine("Потік працює...");
            Thread.Sleep(500); // Імітація роботи
        }
    }
}
```

***Що тут відбувається?***
1. **Змінна `isRunning` оголошена як `volatile`**, що гарантує, що всі потоки бачать її актуальне значення.
2. **Основний потік створює другий потік (`worker`)**, який виконує нескінченний цикл, поки `isRunning == true`.
3. **Коли користувач натискає клавішу**, основний потік змінює `isRunning` на `false`.
4. **Оскільки змінна `volatile`**, допоміжний потік негайно бачить оновлення і завершується.
5. **Використання `volatile` тут важливе**, щоб уникнути кешування змінної окремими потоками і не допустити зависання `while (isRunning)`.
## Reset Events
Для використання системних подій у керованому коді .NET Framework  
існують класи `ManualResetEvent`, `AutoResetEvent`, `ManualResetEventSlim` і  
`CountdownEvent`.
Ці класи є похідними від базового класу `EventWaitHandle`, який знаходиться  
на верхньому рівні ієрархії класів, і застосовуються в тих випадках,  
коли один потік очікує появи певної події в іншому потоці.  
Як тільки ця подія виникає, другий потік повідомляє про це перший потік,  
дозволяючи йому продовжити виконання.
### Використання подій
Застосування подій досить просте.
Наприклад, порядок використання `ManualResetEvent` наступний:
1. Потік, що очікує подію, викликає метод `WaitOne()` для об'єкта події.
2. Якщо об'єкт події знаходиться в сигнальному стані, `WaitOne()` повертає управління одразу.
3. Якщо ні, виконання потоку призупиняється, доки не буде отримано сповіщення про подію.
4. Інший потік може встановити об'єкт події у сигнальний стан, викликавши `Set()`.
5. Після цього `WaitOne()` завершується, і перший потік продовжує виконання.
6. Виклик `Reset()` повертає об'єкт події у несигнальний стан.

Подія `AutoResetEvent` відрізняється від `ManualResetEvent` тим, що повертається  
у несигнальний стан **автоматично**, як тільки один потік отримує повідомлення про подію.  
Тобто **виклик `Reset()` не є обов'язковим**.
Метод `WaitOne()` переводить поточний потік у стан очікування, поки `AutoResetEvent`  
не перейде у сигнальний стан.
Якщо в програмі використовується кілька об'єктів `AutoResetEvent`,  для відстеження їхнього стану можна використовувати `WaitAll` і `WaitAny`,  які приймають масив об'єктів `WaitHandle` (базовий клас для `AutoResetEvent`).
Об'єкт `ManualResetEventSlim` працює аналогічно `ManualResetEvent`,  але призначений для швидшого виконання в умовах **локальної синхронізації**.  
Метод `Set()` переводить об'єкт у сигнальний стан, `Reset()` повертає його  у несигнальний стан.  
Якщо кілька потоків чекають на подію, то `Set()` одразу розблоковує всі очікуючі потоки.  
Якщо потік викликає `WaitOne()`, коли подія вже у сигнальному стані,  
то виконання одразу продовжується.

| Тип події                | Особливості                                                                               |
| ------------------------ | ----------------------------------------------------------------------------------------- |
| **ManualResetEvent**     | `Set()` розблоковує всі потоки. `Reset()` потрібен для повторного блокування.             |
| **AutoResetEvent**       | `Set()` розблоковує лише **один** потік і одразу повертає подію у несигнальний стан.      |
| **ManualResetEventSlim** | Локальна синхронізація, швидше, ніж `ManualResetEvent`, дозволяє всім потокам продовжити. |
#### ManualResetEvent code sample

``` C#
using System;
using System.Threading;

class Program
{
    static ManualResetEvent manualEvent = new ManualResetEvent(false);

    static void Main()
    {
        Thread worker = new Thread(DoWork);
        worker.Start();

        Console.WriteLine("Натисніть Enter, щоб дозволити потоку продовжити...");
        Console.ReadLine();

        manualEvent.Set(); // Дозволяємо потоку продовжити виконання

        worker.Join();
    }

    static void DoWork()
    {
        Console.WriteLine("Очікування сигналу...");
        manualEvent.WaitOne(); // Очікування сигналу
        Console.WriteLine("Потік отримав сигнал і продовжив виконання.");
    }
}
```
***Як це працює?***
Основний потік запускає `worker`, який викликає `WaitOne()` і зупиняється.  
Коли користувач натискає Enter, `Set()` дозволяє потоку продовжити виконання.
#### AutoResetEvent code sample

``` C#
using System;
using System.Threading;

class Program
{
    static AutoResetEvent autoEvent = new AutoResetEvent(false);

    static void Main()
    {
        Thread worker1 = new Thread(DoWork);
        Thread worker2 = new Thread(DoWork);

        worker1.Start();
        worker2.Start();

        Thread.Sleep(1000);
        Console.WriteLine("Основний потік подає сигнал...");
        autoEvent.Set(); // Дозволяє тільки одному потоку продовжити

        Thread.Sleep(1000);
        Console.WriteLine("Подання сигналу ще раз...");
        autoEvent.Set(); // Дозволяє другому потоку продовжити

        worker1.Join();
        worker2.Join();
    }

    static void DoWork()
    {
        Console.WriteLine($"Потік {Thread.CurrentThread.ManagedThreadId} очікує...");
        autoEvent.WaitOne();
        Console.WriteLine($"Потік {Thread.CurrentThread.ManagedThreadId} отримав сигнал!");
    }
}
```
***Як це працює?***
`AutoResetEvent` автоматично повертається у несигнальний стан після розблокування **одного** потоку.  
Коли основний потік викликає `Set()`, тільки **один** очікуючий потік продовжує виконання.
## Foreground and Background tasks
In .NET, there are two types of threads: *foreground and background*. Threads are, by default, created as **foreground threads**. You could set the thread state **explicitly as background**. When you close applications, all background threads are automatically terminated. So, when all the foreground threads complete execution, the application can exit before the background threads return. After all the foreground threads have been stopped, or after the application exits, the system stops all background threads.
# FAQ
## Якщо оголосити асинхронний метод, який повертає void, то як він буде виконуватись?
В такому випадку метод буде виконуватись асинхронно, але так як він нічого не повертає, то він не поверне і інформації про статус свого виконання. Таким чином, при виклику цього методу рантайм не буде очікувати його виконання, а одразу продовжить роботу.