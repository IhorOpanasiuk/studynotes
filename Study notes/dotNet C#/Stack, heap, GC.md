Stack - область пам'яті проекту, що працює за принципом LIFO. Займає 4 МБ в 64-біт системах.
Стек зберігає:
1. локальні велю тайпи
2. посилання на об'єкти в купі
3. параметри методів
4. інформацію про виконання методів

Heap - область пам'яті, в якій зберігаються референс тайпи, розмір не обмежений.

###### All the heaps
In general, there is 1 for the garbage collected heap. But in more details, the three generational heap plus the Large Object Heap are logically distinct heaps. = 4 
Another one that you can't entirely ignore in managed code is the heap that stores static variables. It is associated with the AppDomain. Commonly named "loader heap" in .NET literature. It actually consists of 3 heaps (high frequency, low frequency and stub heap). = 4 + 3 = 7 
Further are the heaps used by native code.There's a default process heap, Windows allocates from it, so does Marshal.AllocHGlobal(). And there's a separate heap where COM stores data, Marshal.AllocCoTaskMem() allocates from it.

###### Where static members located in heap? 
Another one that you can't entirely ignore in managed code is the heap that stores static variables. It is associated with the AppDomain. Commonly named "loader heap" in .NET literature.

###### All the heaps explained detailed
SOH (Small object heap) має 3 генерації:
- Generation 0: нові об'єкти
- Generation 1: об'єкти, що пережили одне прибирання сміття
- Generation 2: довгоживучі об'єкти
  
LOH (Large object heap) зберігає об'єкти, розмір яких перевищує 85 кБ (або масиви елементів більші ніж 1кБ), GC в ній відбувається рідше ніж у SOH через ресурсоємкість керування важкими об'єктами.

POH (Pinned object heap) (.Net 5 +) зберігає об'єкти, які були вручну закріплені, GC в ній **не** відбувається.
Додавання об'єкта до POH:
``` C#
var b = new HttpClient();  
GCHandle.Alloc(b, GCHandleType.Pinned);
```

Loaded heap - це спеціальна область пам'яті, яку .NET використовує для зберігання "службової" інформації, потрібної для роботи програми. Вона не зберігає ваші змінні чи дані напряму, а містить метаінформацію і код, який генерується або використовується під час виконання програми.
Зберігає : 
**High-Frequency Heap** (HFH):
1. Містить дані, до яких часто звертається .NET Runtime:
2. Статичні змінні класів (особливо ті, що є посиланнями).
3. Таблиці диспетчеризації (v-tables).
4. Дані, що використовуються для швидкого доступу до методів.

**Low-Frequency Heap**(LFH):
Містить дані, які використовуються рідше, такі як допоміжна метаінформація або структура для рідкісних операцій.

**Stub Heap** (заглушковий heap):
Використовується для створення та збереження заглушок (thunks):
Для делегатів.
Для міжплатформених викликів між Managed і Unmanaged кодом (P/Invoke, COM-виклики тощо).
Для інтерфейсних методів.

Code Heap (або Execution Engine Heap):
Тут зберігається машинний код, створений JIT-компілятором.
Цей код використовується для виконання методів після їхньої JIT-компіляції.
Metadata Heap:

Тут зберігається метаінформація про типи, методи, властивості і всі інші конструкції, необхідні для виконання програми.
String Literal Heap:

Використовується для зберігання строкових літералів, які є частиною метаданих (наприклад, ім'я класу чи методів).
Це відмінно від звичайного зберігання рядків у Managed Heap.


###### App Domain
При запуску додатку, написаного на C#, ОС створює процес, а середовище CLR створює всередині цього пресу логічний контейнер, який назвається доменом додатку (AppDomain), всередині якого працює запущений додаток. Кожен із AppDOmain буде обслуговувати свій виконуваний файл .NET. Для керування доменом платформа .NET надає клас AppDomain. 
## Garbage collection

#### Алгоритм роботи
Повний алгоритм роботи GC. Припустим, нам треба додати новий об'єкт у купу:
1. **Визначення розміру об'єкта:** Перш за все, GC визначає розмір об'єкта, який потрібно розмістити. Це включає розмір самого об'єкта та будь-які додаткові витрати, такі як службові дані.
2. **Вибір купи (SOH або LOH):** GC вирішує, в яку купу розмістити об'єкт:
    - **Small Object Heap (SOH):** Для об'єктів розміром менше 85 КБ.
    - **Large Object Heap (LOH):** Для об'єктів розміром 85 КБ і більше.
3. **Пошук вільного місця в SOH (для малих об'єктів):** Якщо об'єкт потрапляє в SOH, GC шукає вільне місце в поколінні 0. Він використовує вказівник, який називається "next object pointer" (вказівник на наступний об'єкт), щоб швидко виділяти пам'ять послідовно.
    - **Простір є:** Якщо в поточному поколінні 0 є достатньо місця, об'єкт розміщується відразу після попереднього об'єкта, а вказівник "next object pointer" зміщується на кінець нового об'єкта. Це дуже швидка операція.
    - **Простору немає:** Якщо в поточному поколінні 0 немає достатньо місця, GC запускає збірку покоління 0.
4. **Збірка покоління 0 (якщо потрібно):** Під час збірки покоління 0:
    - **Визначаються живі об'єкти:** GC перевіряє, на які об'єкти в поколінні 0 ще є посилання з програми(тобто які доступпні через гарф доступності).
    - **Живі об'єкти переміщуються в покоління 1:** Об'єкти, що пережили збірку, переміщуються в покоління 1.
    - **Звільняється пам'ять:** Пам'ять, яку займали мертві об'єкти, звільняється.
    - **Після збірки:** GC знову намагається розмістити новий об'єкт в поколінні 0. Якщо місця все ще недостатньо, запускається збірка покоління 1, потім 2, якщо потрібно.
5. **Пошук вільного місця в LOH (для великих об'єктів):** Якщо об'єкт потрапляє в LOH, GC шукає достатньо великий суцільний блок вільної пам'яті.
    - **Простір є:** Якщо такий блок знайдено, об'єкт розміщується в ньому.
    - **Простору немає:** Якщо вільного блоку достатнього розміру немає, GC може запустити збірку LOH (зазвичай під час повної збірки покоління 2).
6. **Збірка LOH (якщо потрібно):** Під час збірки LOH:
    - **Визначаються живі об'єкти:** GC перевіряє, на які об'єкти в LOH ще є посилання з програми.
    - **Звільняється пам'ять:** Пам'ять, яку займали мертві об'єкти, звільняється.
    - **Компактизація (рідко)(дефрагментація):** За замовчуванням LOH не компактизується часто, щоб уникнути значних витрат часу. Компактизація може бути викликана вручну або за певних умов, наприклад, при серйозному браку пам'яті.
7. **Виділення додаткової пам'яті (якщо необхідно):** Якщо після всіх цих кроків все ще немає достатньо місця для розміщення об'єкта, .NET runtime звертається до операційної системи з запитом на виділення додаткової пам'яті для процесу.
### Freachable and FInalize queues
Finalization queue is where every object that needs finalization lands initially. This is determined based on whether he has a Finalize method. When GC finds a garbage object that is on Finalizable queue, it removes object reference from Finalizable queue and puts it on a Freachable queue. There is a specialized CLR thread that is only responsible for monitoring the Freachable queue and when GC adds new items there, he kicks in, takes objects one by one and calls it’s Finalize method.
### Граф доступності - Це граф обєктів який визначає чи доступний об'єкт за корінями графа 
корінями графа в цьому випадку є :
локальні змінні та аргументи методів всіх активних потоків на момент запуску GC
Статичні поля які мають посилання на об'єкти на купі 
Об'єкти, які мають метод Finalize і ще не були завершені.
Граф об'єкта будується від кореня,посилання від коріня до оббєкта 

#### Алгоритм і пріоритетизація обрання купи для очищення
Обрання частини купи, яка буде очищатись іде в такому порядку:
1. Відбувається спроба очистити покоління 0.
2. Якщо після очистки покоління 0 пам'яті всеодно недостатньо, відбувається очистка в поколінні 1.
3. Аналогічно із попереднім, після покоління 1 може відбутись очистка покоління 2.
4. РАЗОМ ІЗ ОЧИСТКОЮ ПОКОЛІННЯ 2 відбувається очистка LOH.
#### Ручна очистка
Garbage Collection можна викликати вручну, для цього потрібно викликати метод `GC.Collect();` , в такому випадку відбудеться очистка всіх поколінь. 
Але також в цього метода є перевантаження, і можна обрати номер покоління для очистки, режим очистки (*Default* автоматично вибере коли, *Forced*, тобто збірка відбувається негайно, і *Optimized*, тобто не одразу, а вибереться оптимальний час). Також можна вказати чи вона буде відбуватись із блокуванням системи, і чи потрібно здійснювати компактизацію.
#### Види GC
Бувають такі види GC:
1. Server GC: Призначений для серверних додатків, типу Asp.Net. Оптимізований для максимальної пропускної здатності, тобто кількості роботи програми за одиницю часу. Використовує більше пам'яті, ніж Workstation GC, але обробляє більші обсяги даних. Також підтримує Concurrent GC. У багатопроцесорних системах може використовувати кілька потоків для паралельної збірки сміття, що значно підвищує продуктивність.
2. Workstation GC: призначений для клієнтських додатків, типу WinForms та WPF. Він оптимізований для мінімізацію pause time, працює в режимі Concurrent GC, використовує менше пам'яті ніж Server GC.
#### Режими GC
Бувають різні режими GC:
1. Background GC(після .Net 4), коли збірка відбувається у фоновому режимі, паралельно із роботою програми, що мінімізує час зупинки.
2. Concurrent GC(до .Net 4), коли збірка відбувається паралельно із роботою програми.
3. Non-concurrent (Stop the World) , коли програма блокується на час збірки сміття. Відбувається рідко.
#### Фрагменатція купи
Фрагментація кучі (heap fragmentation) – це явище, коли в пам'яті, виділеній для динамічного зберігання об'єктів (купі), з'являються розрізнені ділянки вільної пам'яті між зайнятими блоками.
**Види фрагментації:**
- **Зовнішня фрагментація:** Вільна пам'ять розкидана по невеликих блоках між зайнятими ділянками, і не має достатньо великого суцільного блоку для виділення пам'яті під новий об'єкт.
- **Внутрішня фрагментація:** Виділений блок пам'яті більший за розмір об'єкта, що зберігається в ньому. Залишок пам'яті в цьому блоці залишається невикористаним.
**Боротьба з фрагментацією:**
- **Компактизація кучі (Heap compaction):** Збирач сміття може переміщувати об'єкти в купі, щоб звільнити великі суцільні блоки пам'яті. Проте, це затратна операція, яка може призвести до тимчасової зупинки програми.
- **Використання пулів об'єктів (Object pooling):** Попереднє створення набору об'єктів та їх повторне використання замість постійного створення та знищення. Це зменшує кількість операцій виділення та звільнення пам'яті та запобігає фрагментації.

