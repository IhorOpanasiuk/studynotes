[Урла на статті](https://habr.com/ru/users/erogov/publications/articles/page2/)
## Види індексів
Кластеризовані індекси - індекси, які визначають структуру таблиці, вони є одні на таблицю, повинні бути унікальними, і визначають порядок записів в таблиці, дуже часто це ID. Некластеризовані - це усі інші індекси. Вони є допоміжними для пошуку записів по конкретних полях.
Коли база даних шукає дані:
- З кластеризованим індексом вона відразу знаходить потрібні дані, бо вони фізично розташовані разом
- З некластеризованим індексом відбувається двокрокова операція: спочатку пошук у індексі, потім перехід за вказівником до реальних даних
Саме тому кластеризовані індекси зазвичай швидші для зчитування, але повільніші для вставки нових даних, адже може знадобитися фізичне переміщення багатьох рядків для збереження правильного порядку.
КРЧ, коли в таблиці є наприклад кластеризований індекс по ID, то порядок розташування записів в ній, якщо записів 10 із id 1-10 буде такий (з ліва на право, просто щоб менше місця займало розташував горизонтально):

| Name | Alice | Bob | Charlie | Diana | Eve | Frank | Grace | Hannah | Ivy | Jack |
| ---- | ----- | --- | ------- | ----- | --- | ----- | ----- | ------ | --- | ---- |
| ID   | 5     | 3   | 7       | 2     | 9   | 10    | 6     | 4      | 8   | 1    |

Скледені індекси - які індексують кілька стовпців.
```
CREATE INDEX IX_FullName ON Employees(LastName, FirstName);
```
Покриваючі індекси - індексують один або кілька стовпців, але містять також дані із додаткових стовпців які в більшості випадків потрібні для виконання запиту.
```
CREATE INDEX IX_EmployeeInfo ON Employees(LastName, FirstName)
INCLUDE (HireDate, Department);
```
Часткові індеси - індексують ті рядки, які відповідають певній умові.
```
CREATE INDEX IX_ActiveEmployees ON Employees(LastName)
WHERE IsActive = 1;
```
## Реалізації індексів
TID - покажчик на рядок в таблиці БД, часто використовується при індексації.
### B-tree індекс (за замовчуванням)
Найбільш поширений тип. Підходить для порівнянь з операторами <, <=, =, >=, >.
Створює структуру у вигляді бінарного дерева, окремо від основної таблиці. Часто використовується саме B+ дерево.
![[Pasted image 20241217231349.png]]
Кожен вузол містить:
- Значення ключа
- Вказівник на сторінку даних
- Вказівники на дочірні вузли
Приклад створення: 
`CREATE INDEX idx_users_email ON users(email);`

Постгрес юзає b+ дерева, і залежно від умов налаштовує їх по-різному:
###### **а) Кількість елементів у вузлах:**
- PostgreSQL динамічно налаштовує розмір вузлів залежно від розміру сторінок, який дорівнює 8 КБ за замовчуванням (це можна змінити при компіляції).
- Вузол B+ дерева заповнюється так, щоб ефективно використовувати ці 8 КБ.
- Алгоритм підтримує **автоматичне балансування** дерева для мінімізації висоти.
###### **б) Сортування:**
- Індекс створюється в **зростаючому порядку** за замовчуванням.
- Можна вказати `DESC` для зворотного порядку:
    `CREATE INDEX idx_desc ON table_name(column_name DESC);`
###### **в) Заповненість вузлів (fillfactor):**
- PostgreSQL дозволяє контролювати, наскільки вузли будуть заповнені при створенні індекса.
- Параметр `fillfactor` задає, який відсоток простору вузлів заповнено:
    `CREATE INDEX idx_name ON table_name(column_name) WITH (fillfactor = 70);`
    - За замовчуванням вузли заповнюються на 90%, щоб залишити місце для майбутніх вставок.
Під час виконання операцій вставки або видалення PostgreSQL автоматично підтримує балансування дерева. 
Дублікати ключів зберігаються в одному вузлі, що дозволяє ефективно працювати з даними, які повторюються.
### HASH-індекс
Робить із набору індексованих значень хеші, які записує у певні бакети (по кілька хешів на бакет максимум). Кількість бакетів БД сама обирає. Коли отримує запит на знаходження певного значення, хешує його, і бере остачу від ділення хешу на кількість бакетів. Таким чином знаходить бакет в якому потім підбирає значення. Головною ціллю індексації є знаходження бакета, а знайти за значенням хешу об'єкт всередині бакета вже не буде складно.
![[Pasted image 20241217232022.png]]
Приклад створення:
`CREATE INDEX idx_users_email USING HASH ON users(email)`
### GiST(Generalized Search Tree) індекси
Гнучкий тип індексу, який використовується для складних типів даних та операцій. GIST допомагає швидко знаходити об'єкти, які розташовані поруч один з одним або перетинаються.
Його особливістю є те, що він дозволяє визначити правила для групування та порівняння даних.
Приклад:
`CREATE INDEX idx_locations ON cities USING GIST(location) 
`SELECT * FROM cities 
`WHERE location <-> point '(longtitude,latitude) < 5000'`

##### Приклад: GiST для геометрії
Уявіть, що ви зберігаєте геометричні об'єкти (наприклад, прямокутники):
1. У листових вузлах дерева знаходяться координати кожного об'єкта.
2. У внутрішніх вузлах знаходяться bounding boxes, які охоплюють всі геометричні об'єкти в дочірніх вузлах.
Запит типу "знайти всі об'єкти, що перетинають вказаний прямокутник" працює так:
1. Починаючи з кореня, перевіряється, чи bounding box вузла перетинається із заданим прямокутником.
2. Якщо перетинається, GiST продовжує пошук у дочірніх вузлах.
3. У листових вузлах перевіряється кожен об'єкт на перетин із прямокутником.
### SP-GiST

Space-Partitioned Generalized Search Tree має іншу структуру ніж Gist. Якщо Гіст має структуру звичайного b-дерева, то sp-gist розбиває простір на неперекривні області. Це означає, що якщо уявити дерево сп-гіста як квадрат, то корінь буде увесь квадрат, 2 дочірні від кореня ноди будуть прямокутниками по половині площі, 4 дочірні від них будуть квадратами-четвертинками і так далі. 

### GIN (Generalized Inverted Index)
Gin - це інвертований індекс, оптимізований для роботи із множинами.
Суть в тому, що він індексує значення які зберігаються в кожному записі множин, умовно є рядки із такими значеннями: [1,2,3] і [3,4,5]. Gin буде створювати b-tree із цих значень в масивах, і до кожного прив'язувати ссилки на записи (масивчики) в яких зберігається це значення.
Із особливостей також те, що елементи в таких індексіціях не видаляються, навіть якщо немає ссилок на масиви, бо очікується, що такий масив доволі імовірно може з'явитись.
![[Pasted image 20241217231022.png]]

### BRIN (Block range index)
Придуманий для не настільки пошуку, як виключення варіантів для пошуку у дуже великих таблицях. Взагалі в БД дані зберігаються у вигляді блоків по 8Кб. Брін дозволяє відкидати цілі блоки при пошуку даних за допомогою того, що він бере тільки деякі дані про кожен блок:
1. мінімальне і максимальне значення
2. статистичні властивості
За рахунок зберігання таких досить маленьких даних, але дуже потрібних при пошуку є можливість відкидати цілі блоки для пошуку даних. **Після BRIN** використовується сканування (по індексах b-tree чи Gist або банальний пошук без індексу) лише тих діапазонів, які відповідають критеріям запиту.
BRIN працює ефективно, якщо дані у таблиці **локально впорядковані** (наприклад, часові ряди, географічні дані). У цьому випадку мінімальні й максимальні значення добре відповідають реальному розподілу даних.